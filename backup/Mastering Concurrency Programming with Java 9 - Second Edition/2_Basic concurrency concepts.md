# 기본 동시성 개념

우선 동시성의 기본 개념을 설명하겠습니다. 이 개념들을 이해해야만 책의 나머지 부분을 따라갈 수 있다.

## 동시성 대 병렬성(Concurrency versus parallelism)

동시성과 병렬성은 매우 유사한 개념입니다. 저자마다 이러한 개념에 대해 서로 다른 정의를 제공합니다. 가장 널리 사용되는 정의는 단일 코어가 있는 단일 프로세서에 둘 이상의 작업(태스크)이 있을 때 동시성을 말합니다. 이 경우 운영 체제의 작업 스케줄러가 한 작업에서 다른 작업으로 빠르게 전환하므로 모든 작업이 동시에 실행되는 것처럼 보입니다. 동일한 정의는 병렬 처리에 대해 서로 다른 컴퓨터, 프로세서 또는 프로세서 내부의 코어에서 동시에 실행되는 둘 이상의 작업이 있는 경우를 말합니다.

또 다른 정의는 시스템에서 동시에 실행되는 둘 이상의 작업 (다른 작업)이 있을 때의 동시성에 대해 설명합니다. 또 다른 정의는 데이터 세트(집합)의 서로 다른 부분에 걸쳐 동시에 실행되는 동일한 작업의 다른 인스턴스가 있을 때 병렬 처리를 설명합니다.

마지막 정의는 병렬 처리가 시스템에서 동시에 실행되는 작업이 두 개 이상 있을 때를 말하며 프로그래머가 작업 및 공유 리소스에 대한 액세스와 동기화 해야하는 다양한 기술 및 메커니즘을 설명하는 방법으로 동시성에 대해 설명합니다.

보시다시피 두 개념은 매우 유사하며 이러한 유사성은 멀티 코어 프로세서의 개발과 함께 증가했습니다.

## 동기화 (Synchronization)
동시성에서는 원하는 결과를 얻기 위해 둘 이상의 작업을 조정하는 것으로 동기화를 정의 할 수 있습니다. 두 가지 종류의 동기화가 있습니다.


* 동기화 제어(Control synchronization): 예를 들어 한 작업이 다른 작업의 끝에 따라 달라지는 경우 첫 번째 작업이 완료되기 전에 두 번째 작업을 시작할 수 없음
* 데이터 액세스 동기화(Data access synchronization): 둘 이상의 작업이 공유 변수에 액세스 할 수 있고 작업 중 하나만 변수에 액세스 할 수 있는 경우


동기화와 밀접한 관련이 있는 개념은 중요한 부분입니다. 중요 섹션은 공유 리소스에 대한 액세스로 인해 한 번에 하나의 작업만 실행할 수 있는 코드 조각입니다. 상호 배제는 이 요구사항을 보증하는 데 사용되는 메커니즘이며 다른 방법으로 구현될 수 있다.

동기화는 동시 작업에서 발생할 수 있는 오류를 방지하는 데 도움이 되지만(이 장 뒷부분에서 설명됨) 알고리즘에 약간의 오버헤드가 발생한다는 점에 유의하십시오. 병렬 알고리즘에서 상호 통신 없이 독립적으로 수행할 수 있는 작업 수를 매우 신중하게 계산해야 합니다. 이것은 동시 알고리즘의 세분화입니다. 조잡한 세분화(상호 통신이 적은 큰 작업)가 있는 경우 동기화로 인한 오버헤드가 낮아집니다. 그러나 시스템의 모든 코어를 활용할 수는 없습니다. 세분화된 세부 사항(상호 통신의 작은 작업)이 있는 경우 동기화로 인한 오버헤드가 높으며 알고리즘 처리량이 좋지 않을 수 있습니다.

동시 시스템에서 동기화를 얻는 다른 메커니즘이 있습니다. 이론적 관점에서 가장 널리 사용되는 메커니즘은 다음과 같습니다.

* 세마포어(Semaphore): 세마포어는 하나 이상의 리소스 단위에 대한 액세스를 제어하는 데 사용할 수 있는 메커니즘입니다. 사용할 수 있는 리소스 수와 변수 값을 관리하기 위한 두 개의 원자성 작업을 저장하는 변수가 있습니다. 뮤텍스(상호 제외의 줄임말)는 두 개의 값(리소스 사용 가능 및 리소스 사용 중)만 사용할 수 있는 특수한 종류의 세마포어이며, 뮤텍스를 사용 중으로 설정하는 프로세스만 해제할 수 있습니다. 뮤텍스는 중요한 섹션을 보호하여 레이스 상태를 방지하는 데 도움이 됩니다.
* 모니터(Monitor): 모니터는 공유 리소스에 대한 상호 제외를 가져오는 메커니즘입니다. 여기에는 음소거, 조건 변수 및 두 가지 작업이 있어 조건을 기다리고 조건을 알릴 수 있습니다. 조건에 신호를 보내면 해당 조건을 기다리는 태스크 중 하나만 실행을 계속합니다.

이 장에서 배울 동기화와 관련된 마지막 개념은 스레드 안전(thread-safe)입니다. 공유 데이터의 모든 사용자가 동기화 메커니즘에 의해 보호되는 경우 코드 조각(또는 메서드 또는 개체)은 스레드 안전(thread-safe)합니다. 데이터의 비차단, 비교 및 교환(compare-and-swap, CAS) 원시 데이터는 불변하므로 이 코드를 동시에 사용하는 데 문제가 없습니다.

## 불변 객체(Immutable object)

불변객체는 매우 특별한 특성을 가진 객체이다. 초기화 후에는 표시 상태(속성의 값)를 수정할 수 없습니다. 불변 개체를 수정하려면 새 개체를 만들어야 합니다.

그것의 주된 장점은 스레드로부터 안전하다는 것이다. 동시 응용 프로그램에서 문제 없이 사용할 수 있습니다.

불변 객체의 예로는 Java의 String 클래스가 있습니다. 문자열 개체에 새 값을 할당하면 새 값이 만들어집니다.

## 공유 메모리 대 메시지 전달(Shared memory versus message passing)

작업은 서로 통신하기 위해 두 가지 다른 방법을 사용할 수 있습니다. 첫 번째는 공유 메모리이며 일반적으로 태스크가 동일한 시스템에서 실행될 때 사용됩니다. 태스크는 값을 쓰고 읽는 동일한 메모리 영역을 사용합니다. 문제를 방지하려면 이 공유 메모리에 대한 액세스가 동기화 메커니즘으로 보호되는 중요한 섹션에 있어야 합니다.

다른 동기화 메커니즘은 메시지 전달이며 일반적으로 태스크가 다른 시스템에서 실행될 때 사용됩니다. 태스크가 다른 태스크와 통신해야 하는 경우 미리 정의된 프로토콜을 따르는 메시지를 전송합니다. 이 통신은 발신인이 응답을 기다리는 동안 차단된 상태로 유지하면 동기화될 수 있으며, 메시지를 보낸 후 실행을 계속하는 경우에는 비동기화될 수 있습니다.